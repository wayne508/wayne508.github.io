<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="os," />





  <link rel="alternate" href="/atom.xml" title="Wayne's Blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="1 总述bootloader的程序存放在硬盘的第一个扇区（512B）。BIOS程序会将bootloader加载到内存0x7c00处，并跳转到这里执行。 bootloader的主要作用：  打开A20地址线，使CPU进入32位实模式； 探测物理内存大小； 设置CR0，进入32位保护模式； 加载内核镜像，把控制权交给内核。  2 准备 进入bootloader后，为了后向兼容，此时的CPU是16位模式">
<meta name="keywords" content="os">
<meta property="og:type" content="article">
<meta property="og:title" content="ucore源码分析：bootloader">
<meta property="og:url" content="http://roughtale.info/2015/08/20/ucore源码分析：bootloader/index.html">
<meta property="og:site_name" content="Wayne&#39;s Blog">
<meta property="og:description" content="1 总述bootloader的程序存放在硬盘的第一个扇区（512B）。BIOS程序会将bootloader加载到内存0x7c00处，并跳转到这里执行。 bootloader的主要作用：  打开A20地址线，使CPU进入32位实模式； 探测物理内存大小； 设置CR0，进入32位保护模式； 加载内核镜像，把控制权交给内核。  2 准备 进入bootloader后，为了后向兼容，此时的CPU是16位模式">
<meta property="og:image" content="http://roughtale.info/2015/08/20/ucore源码分析：bootloader/a38fed2f8c0df5e4cf3b9e6186471.JPG">
<meta property="og:updated_time" content="2017-05-18T08:48:25.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ucore源码分析：bootloader">
<meta name="twitter:description" content="1 总述bootloader的程序存放在硬盘的第一个扇区（512B）。BIOS程序会将bootloader加载到内存0x7c00处，并跳转到这里执行。 bootloader的主要作用：  打开A20地址线，使CPU进入32位实模式； 探测物理内存大小； 设置CR0，进入32位保护模式； 加载内核镜像，把控制权交给内核。  2 准备 进入bootloader后，为了后向兼容，此时的CPU是16位模式">
<meta name="twitter:image" content="http://roughtale.info/2015/08/20/ucore源码分析：bootloader/a38fed2f8c0df5e4cf3b9e6186471.JPG">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 'undefined',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://roughtale.info/2015/08/20/ucore源码分析：bootloader/"/>





  <title>ucore源码分析：bootloader | Wayne's Blog</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Wayne's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://roughtale.info/2015/08/20/ucore源码分析：bootloader/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ucore源码分析：bootloader</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-08-20T03:15:12+08:00">
                2015-08-20
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/08/20/ucore源码分析：bootloader/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2015/08/20/ucore源码分析：bootloader/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="1-总述"><a href="#1-总述" class="headerlink" title="1 总述"></a>1 总述</h2><p>bootloader的程序存放在硬盘的第一个扇区（512B）。BIOS程序会将bootloader加载到内存0x7c00处，并跳转到这里执行。</p>
<p>bootloader的主要作用：</p>
<ol>
<li>打开A20地址线，使CPU进入32位实模式；</li>
<li>探测物理内存大小；</li>
<li>设置CR0，进入32位保护模式；</li>
<li>加载内核镜像，把控制权交给内核。</li>
</ol>
<h2 id="2-准备"><a href="#2-准备" class="headerlink" title="2 准备"></a>2 准备</h2><ol>
<li><p>进入bootloader后，为了后向兼容，此时的CPU是16位模式（20根地址线，16位地址模式），20-31的地址线为0。此时的汇编代码应该有“.code16”前缀，表示16位模式。</p>
</li>
<li><p>在bootloader执行过程中，必须关闭中断，将数据段、附加段、堆栈段的段寄存器设置为0。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.code16                                             # Assemble for 16-bit mode</div><div class="line">    cli                                             # Disable interrupts</div><div class="line">    cld                                             # String operations increment</div><div class="line"></div><div class="line">    # Set up the important data segment registers (DS, ES, SS).</div><div class="line">    xorw %ax, %ax                                   # Segment number zero</div><div class="line">    movw %ax, %ds                                   # -&gt; Data Segment</div><div class="line">    movw %ax, %es                                   # -&gt; Extra Segment</div><div class="line">    movw %ax, %ss                                   # -&gt; Stack Segment</div></pre></td></tr></table></figure>
<h2 id="3-打开A20"><a href="#3-打开A20" class="headerlink" title="3 打开A20"></a>3 打开A20</h2><h3 id="3-1-背景"><a href="#3-1-背景" class="headerlink" title="3.1 背景"></a>3.1 背景</h3><p>为了兼容16位地址模式，32位CPU使用键盘控制器（8042控制器）的一个控制线（即A20控制线）来控制20-31位地址线的打开关闭。当A20控制线打开时可以使用20-31的地址线。而当A20 关闭时20-31的地址线全部为0。</p>
<h3 id="3-2-8042控制器"><a href="#3-2-8042控制器" class="headerlink" title="3.2 8042控制器"></a>3.2 8042控制器</h3><p>8042控制器内部拥有4个8位寄存器：状态寄存器、输出寄存器、输入寄存器、控制寄存器，对外通过两个I/O端口：0x64（命令端口）、0x60（数据端口）进行通信。</p>
<p>状态寄存器各位的定义如下：</p>
<ul>
<li>Bit7: 从键盘获得的数据奇偶校验错误</li>
<li>Bit6: 接收超时，置1</li>
<li>Bit5: 发送超时，置1</li>
<li>Bit4: 为1，键盘没有被禁止。为0，键盘被禁止。</li>
<li>Bit3: 为1，输入缓冲器中的内容为命令，为0，输入缓冲器中的内容为数据。</li>
<li>Bit2: 系统标志，加电启动置0，自检通过后置1</li>
<li>Bit1: 输入缓冲器满置1，i8042 取走后置0</li>
<li>BitO: 输出缓冲器满置1，CPU读取后置0</li>
</ul>
<p>读写0x64和0x60的含义：</p>
<ul>
<li>读取0x64端口时，返回状态寄存器的内容，可以判断8042控制器的忙闲状态；</li>
<li>写0x64端口时，一般写入操作命令。</li>
<li>读写0x60端口一般都跟在写0x64端口后，主要作用是读取发送操作命令后控制器的响应，或者写入操作命令需要的参数。</li>
</ul>
<p>举个例子，如果要读取8042的控制寄存器的内容，需要发送20h命令，控制器就会把结果放在输出缓存器中等待CPU取走，接下来读取0x60端口读取内容；如果要写控制寄存器的内容，要发送60h命令，接下来将要设置的内容通过0x60端口写入。</p>
<p>但需要注意的是，无论是通过哪个端口（0x60、0x64）写入数据，都需要等待8042的输入缓存为空，否则就会冲掉上次的输入。判断输入缓存为空只需要判断状态寄存器的第2位是否为0（见状态寄存器的Bit1位）。</p>
<h3 id="3-3-A20使能"><a href="#3-3-A20使能" class="headerlink" title="3.3 A20使能"></a>3.3 A20使能</h3><p>A20控制线是8042输出端口的第2位，只要设置该输出端口为1，就可以打开A20。写输出端口的命令是0xD1。那么整个流程可以描述为：1）等待输入缓存为空；2）从0x64端口写入0xD1命令；3）等待输入缓存为空；4）从0x60端口写入要设置的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">seta20.1:</div><div class="line">    inb $0x64, %al                                  # 读取状态寄存器</div><div class="line">    testb $0x2, %al                                 # 判断输入缓存是否为空</div><div class="line">    jnz seta20.1</div><div class="line">	# 0xd1表示写输出端口命令，参数随后通过0x60端口写入</div><div class="line">    movb $0xd1, %al                     </div><div class="line">    outb %al, $0x64</div><div class="line">                      </div><div class="line"># 等待8042将输入命令取走</div><div class="line">seta20.2:</div><div class="line">    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</div><div class="line">    testb $0x2, %al</div><div class="line">    jnz seta20.2</div><div class="line">    # 通过0x60写入数据 11011111</div><div class="line">    movb $0xdf, %al                                 # 0xdf -&gt; port 0x60</div><div class="line">    outb %al, $0x60                                 # 0xdf = 11011111, means set P2&apos;s A20 bit(the 1 bit) to 1</div></pre></td></tr></table></figure>
<h2 id="4-探测物理内存分布"><a href="#4-探测物理内存分布" class="headerlink" title="4 探测物理内存分布"></a>4 探测物理内存分布</h2><p>内核在管理内存前，需要知道物理内存的分布情况，哪些部分可以使用，哪些部分不能使用。内存分布情况可以通过BIOS中断来获取，具体就是INT 15h，参数eax为0xe820。</p>
<p>在调用INT 15h中断获取内存分布情况时，需要设置一些输入参数：</p>
<ol>
<li>设置eax为0xE820</li>
<li>es:edi指向缓存区，缓存返回的内存分布描述符（Address Range Descriptor），表示内存段的状态。</li>
<li>ecx存放返回数据的大小，也就是内存分布描述符的大小，一般BIOS总是返回20字节</li>
<li>edx的值为0x534d4150，也就是“SMAP”的ASCII码。</li>
</ol>
<p>输出：</p>
<ol>
<li>CF为1表示出现错误，否则无错</li>
<li>eax为“SMAP”的ASCII码，用于验证BIOS的返回是否正确。</li>
<li>es:di：返回内存分布描述符的地址，与输入值一样</li>
<li>ebx：返回获取下一描述符的后续值，作为下次中断的输入值。如果为0，则表示所有描述符获取完毕。</li>
</ol>
<p>我们可以利用INT 15h获取到多个内存分布描述符。在ucore中，这些内存分布描述符存放在连续的内存空间中，也就是一个数组中，这个数组的起始地址为0x8004；而这个数组的长度存放在0x8000-0x8003的四字节内存中，作为整形使用。在kern/mm/memlayout.h中确实定义了等价的结构体e820map来表示这段内存：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">struct e820map &#123;</div><div class="line">    int nr_map;                # 4字节，表示描述符的数量</div><div class="line">    struct &#123;                   # 20字节的结构体</div><div class="line">        uint64_t addr;             # 8字节，表示内存段的起始地址</div><div class="line">        uint64_t size;             # 8字节，表示内存段的大小</div><div class="line">        uint32_t type;             # 4字节，表示内存段的类型：保留或空闲</div><div class="line">    &#125; __attribute__((packed)) map[E820MAX];   # 这是一个结构体数组</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>再回到如何利用INT 15h获取e820map的汇编代码吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">probe_memory:</div><div class="line">    movl $0, 0x8000          # 0x8000-0x8003代表e820map中的nr_map，初始值为0</div><div class="line">    xorl %ebx, %ebx          # ebx初始值设为0，以后每次的返回值作为输入</div><div class="line">    movw $0x8004, %di        # 0x8004代表e820map中数组map的初始地址</div><div class="line">start_probe:</div><div class="line">    movl $0xE820, %eax       # 给eax赋值为E820，由于eax会被修改，所以这条语句放在循环中，重复赋值为E820</div><div class="line">    movl $20, %ecx</div><div class="line">    movl $SMAP, %edx</div><div class="line">    int $0x15</div><div class="line">    jnc cont</div><div class="line">    movw $12345, 0x8000     # 出错后，将nr_map赋值为12345</div><div class="line">    jmp finish_probe</div><div class="line">cont:</div><div class="line">    addw $20, %di         # 缓存区地址增加20字节，也就是数组的下一元素</div><div class="line">    incl 0x8000           # nr_map++</div><div class="line">    cmpl $0, %ebx</div><div class="line">    jnz start_probe       # 判断是否存在下一个内存分布描述符</div><div class="line">finish_probe:</div></pre></td></tr></table></figure>
<h2 id="5-进入保护模式"><a href="#5-进入保护模式" class="headerlink" title="5 进入保护模式"></a>5 进入保护模式</h2><p>将gdtdesc加载到gdtr。gdtdesc指向一块6字节内存，其中包含了全局描述符表（gdt）的位置和长度。</p>
<p>gdt和gdtdesc的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">gdt:</div><div class="line">    SEG_NULLASM                                     # null seg</div><div class="line">    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel</div><div class="line">    SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel</div><div class="line"></div><div class="line">gdtdesc:</div><div class="line">    .word 0x17                                      # sizeof(gdt) - 1</div><div class="line">    .long gdt                                       # address gdt</div></pre></td></tr></table></figure></p>
<p>接下来设置cr0的PE位（第0位）为1，开启保护模式。此时全局描述符表开始起作用，其中代码段和数据段的段基址均为0，也就是说此时的虚拟地址和线性地址是相等的。由于此时也没有开启分页模式，线性地址也就是物理地址。最后通过一条长跳转指令，进入32位代码段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">lgdt gdtdesc</div><div class="line">movl %cr0, %eax</div><div class="line">orl $CR0_PE_ON, %eax</div><div class="line">movl %eax, %cr0</div><div class="line">ljmp $PROT_MODE_CSEG, $protcseg</div></pre></td></tr></table></figure>
<p>接下来设置个数据段的段选择子（代码段的段选择子在ljmp执行后自动设置好），设置堆栈空间为0-0x7C00。堆栈设置好以后就可以调用C函数了。最后调用bootmain函数，此函数的主要作用就是从硬盘读取内核并加载到内存中并执行。</p>
<h2 id="6-加载内核"><a href="#6-加载内核" class="headerlink" title="6 加载内核"></a>6 加载内核</h2><p>这部分的代码在boot/bootmain.c中，主要功能是从硬盘中读取内核（ELF文件）并加载到内存中。</p>
<h3 id="6-1-磁盘操作"><a href="#6-1-磁盘操作" class="headerlink" title="6.1 磁盘操作"></a>6.1 磁盘操作</h3><p>对磁盘的操作需要通过IDE接口实现。其中IDE主通道的IO地址为0x1F0-0x1F7，IDE次通道的IO地址为0x170-0x177。每个通道可以挂载两块硬盘。这里需要操作的是第一个通道的第一块硬盘。</p>
<p>对硬盘的读写有两种模式：CHS和LBA（logic block address）。CHS也就是通过柱面、磁头、扇区的方式读写硬盘，LBA就像内存一样，通过线性地址来访问磁盘。</p>
<p>下面介绍LBA的方式读取硬盘。</p>
<p>0x1F0 - 0x1F7的IO端口含义如下：</p>
<ul>
<li>0x1f0: 读/写数据</li>
<li>0x1f1: 读取错误状态</li>
<li>0x1f2: 读/写的扇区数目</li>
<li>0x1f3: LBA的0-7位(相当于扇区)</li>
<li>0x1f4: LBA的8-15位（相当于柱面）</li>
<li>0x1f5: LBA的16-23位(相当于柱面)</li>
<li>0x1f6: bit7、bit5必须为1；bit6：0为CHS模式，1为LBA模式；bit4：0为主盘，1为从盘；bit3-0：LBA的27-24位。</li>
<li>0x1f7: 命令/状态寄存器。发送命令或读取状态。</li>
</ul>
<p>状态寄存器的各位被设置的含义：</p>
<ul>
<li>Bit7: 控制器忙</li>
<li>Bit6: 正常运转（停止转动或出错，该位清零）</li>
<li>Bit5: 控制器严重错误</li>
<li>Bit4: Overlapped Mode Service Request</li>
<li>Bit3: 控制器发出来数据或者准备好接收数据</li>
<li>Bit0: 出错</li>
</ul>
<p>那么操作硬盘的步骤具体如下：</p>
<ol>
<li>等待硬盘控制器不忙</li>
<li>写入操作硬盘的参数：模式、地址、主从盘等</li>
<li>读/写数据</li>
</ol>
<h3 id="6-2-读取扇区"><a href="#6-2-读取扇区" class="headerlink" title="6.2 读取扇区"></a>6.2 读取扇区</h3><p>ucore将读取扇区的操作封装在函数readsect中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">static void waitdisk(void) &#123;</div><div class="line">    while ((inb(0x1F7) &amp; 0xC0) != 0x40)  // 读取状态寄存器，等待空闲</div><div class="line">        /* do nothing */;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 读取扇区号为secno的扇区到内存dst的地址中 */</div><div class="line">static void readsect(void *dst, uint32_t secno) &#123;</div><div class="line">    waitdisk();</div><div class="line"></div><div class="line">    outb(0x1F2, 1);                         // 读取扇区数为1</div><div class="line">    outb(0x1F3, secno &amp; 0xFF);            // secno的0-7位</div><div class="line">    outb(0x1F4, (secno &gt;&gt; 8) &amp; 0xFF);     // secno的8-15位</div><div class="line">    outb(0x1F5, (secno &gt;&gt; 16) &amp; 0xFF);    // secno的16-23位</div><div class="line">    outb(0x1F6, ((secno &gt;&gt; 24) &amp; 0xF) | 0xE0);  // secno的24-27位；0xE0=11100000b表示LBA模式、操作第一块硬盘</div><div class="line">    outb(0x1F7, 0x20);                      // 0x20读扇区命令</div><div class="line"></div><div class="line">    // wait for disk to be ready</div><div class="line">    waitdisk();</div><div class="line"></div><div class="line">    insl(0x1F0, dst, SECTSIZE / 4);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>readseg函数调用了readsect函数，它的主要作用就是从内核偏移量为offset的地方读取count字节的数据，存放在起始位置为va的内存中。因为readsect是以整个扇区为单位读取，所以该函数读取的内容大于等于count。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">static void readseg(uintptr_t va, uint32_t count, uint32_t offset) &#123;</div><div class="line">    uintptr_t end_va = va + count;      // 计算内存段可能的终止位置</div><div class="line"></div><div class="line">    // round down to sector boundary</div><div class="line">    va -= offset % SECTSIZE;            // 与扇区边界对齐</div><div class="line"></div><div class="line">    // translate from bytes to sectors; kernel starts at sector 1</div><div class="line">    uint32_t secno = (offset / SECTSIZE) + 1;  // 内核起始位置在第一个扇区（第0个扇区为bootloader）</div><div class="line"></div><div class="line">    // If this is too slow, we could read lots of sectors at a time.</div><div class="line">    // We&apos;d write more to memory than asked, but it doesn&apos;t matter --</div><div class="line">    // we load in increasing order.</div><div class="line">    for (; va &lt; end_va; va += SECTSIZE, secno ++) &#123;</div><div class="line">        readsect((void *)va, secno);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="6-3-ELF文件"><a href="#6-3-ELF文件" class="headerlink" title="6.3 ELF文件"></a>6.3 ELF文件</h3><p>ELF文件是指可执行链接格式（Executable and Linking Format），最初由UNIX 系统实验室开发并发布的，作为应用程序二进制接口的一部分，也是Linux的主要可执行文件。</p>
<p>ELF文件有三种类型：1) 可重定位文件，也就是通常称的目标文件，后缀为.o。2) 共享文件：也就是通常称的库文件，后缀为.so。3) 可执行文件：本文主要考虑的文件格式。</p>
<p>文件格式：<br><img src="a38fed2f8c0df5e4cf3b9e6186471.JPG" alt="文件格式"></p>
<ul>
<li>ELF头部：用来描述整个文件的组织</li>
<li>程序头部表：是一个结构数组，它的大小等于ELF头表中字段e_phnum定义的条目，结构描述一个段或其他系统准备执行该程序所需要的信息。</li>
</ul>
<p>ucore中定义的ELF头结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">struct elfhdr &#123;</div><div class="line">    uint32_t e_magic;     // must equal ELF_MAGIC</div><div class="line">    uint8_t e_elf[12];</div><div class="line">    uint16_t e_type;      // 1=relocatable, 2=executable, 3=shared object, 4=core image</div><div class="line">    uint16_t e_machine;   // 3=x86, 4=68K, etc.</div><div class="line">    uint32_t e_version;   // file version, always 1</div><div class="line">    uint32_t e_entry;     // entry point if executable</div><div class="line">    uint32_t e_phoff;     // file position of program header or 0</div><div class="line">    uint32_t e_shoff;     // file position of section header or 0</div><div class="line">    uint32_t e_flags;     // architecture-specific flags, usually 0</div><div class="line">    uint16_t e_ehsize;    // size of this elf header</div><div class="line">    uint16_t e_phentsize; // size of an entry in program header</div><div class="line">    uint16_t e_phnum;     // number of entries in program header or 0</div><div class="line">    uint16_t e_shentsize; // size of an entry in section header</div><div class="line">    uint16_t e_shnum;     // number of entries in section header or 0</div><div class="line">    uint16_t e_shstrndx;  // section number that contains section name strings</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>其中：</p>
<ul>
<li>e_magic是0x7f、’E’、’L’、’F’，常数</li>
<li>e_elf[12]存放一些系统信息</li>
<li>e_phoff：程序头部表在文件中的位置</li>
<li>e_phnum：程序头部表中元素个数</li>
<li>e_entry：可执行程序入口</li>
</ul>
<p>紧跟着ELF头部的就是<em>程序头部表</em>，它是一个数组，数组项的结构定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">struct proghdr &#123;</div><div class="line">    uint32_t p_type;   // loadable code or data, dynamic linking info,etc.</div><div class="line">    uint32_t p_offset; // 对应的段在文件中的位置</div><div class="line">    uint32_t p_va;     // 需要映射的虚拟地址</div><div class="line">    uint32_t p_pa;     // 物理地址，没用</div><div class="line">    uint32_t p_filesz; // 段在文件中的大小</div><div class="line">    uint32_t p_memsz;  // 段在内存中的大小</div><div class="line">    uint32_t p_flags;  // 段的标志</div><div class="line">    uint32_t p_align;  // 是否对齐</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>加载内核就是根据<em>程序头部表</em>的内容，将所有代码段加载到对应的内存中，并从ELF头部的可执行入口执行程序。</p>
<ol>
<li>首先bootloader将内核最开始4k的内容加载到内容64k的地方。这4k的内容包含了ELF头部和程序头部表的内容。</li>
<li>遍历程序头部表，根据每一项的内容，加载对应的段到内存中。</li>
<li>从ELF头部的e_entry项执行程序。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">void bootmain(void) &#123;</div><div class="line">    readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);  // 读取4k到ELFHDR位置</div><div class="line"></div><div class="line">    // is this a valid ELF?</div><div class="line">    if (ELFHDR-&gt;e_magic != ELF_MAGIC) &#123;</div><div class="line">        goto bad;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    struct proghdr *ph, *eph;</div><div class="line"></div><div class="line">    // load each program segment (ignores ph flags)</div><div class="line">    ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR-&gt;e_phoff); //程序头部表起始位置</div><div class="line">    eph = ph + ELFHDR-&gt;e_phnum;   //程序头部表终止位置</div><div class="line">    for (; ph &lt; eph; ph ++) &#123;</div><div class="line">        // 加载段到地址p_va&amp;0xFFFFFF中。</div><div class="line">        readseg(ph-&gt;p_va &amp; 0xFFFFFF, ph-&gt;p_memsz, ph-&gt;p_offset);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // call the entry point from the ELF header</div><div class="line">    // note: does not return</div><div class="line">    ((void (*)(void))(ELFHDR-&gt;e_entry &amp; 0xFFFFFF))();</div><div class="line"></div><div class="line">bad:</div><div class="line">    outw(0x8A00, 0x8A00);</div><div class="line">    outw(0x8A00, 0x8E00);</div><div class="line"></div><div class="line">    /* do nothing */</div><div class="line">    while (1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里需要注意一点，段被加载到的物理内存对应的虚拟地址应该是ph-&gt;p_va，但这里是ph-&gt;p_va &amp; 0xFFFFFF，这是为什么？</p>
<p>文件tools/kernel.ld是链接产生内核的ld脚本。从中可以看到代码段的起始虚拟地址是0xC0100000。内核实际被加载到了0xC0100000 &amp; 0xFFFFFF = 0x100000的物理地址中，也就是内存起始1M的地方。当前代码段和数据段的段基址均为0，且没有开启分页机制，虚拟地址等于物理地址。为了让内核正常运行，需要把虚拟地址0xC0100000映射到物理地址0x100000处。所以进入内核的第一件事就是重新设置gdt，设置代码段和数据段的段基址为-0xC0000000。这部分不在bootloader中，这里不详述了。</p>
<p>另外，为了正确进入内核入口地址时，也需要和0xFFFFFF相与：ELFHDR-&gt;e_entry &amp; 0xFFFFFF = ELFHDR-&gt;e_entry - 0xC0000000，这是内核入口的真正物理地址。</p>
<h2 id="7-参考"><a href="#7-参考" class="headerlink" title="7 参考"></a>7 参考</h2><ol>
<li><a href="http://wiki.osdev.org/%228042%22\_PS/2\_Controller" target="_blank" rel="external">http://wiki.osdev.org/%228042%22\_PS/2\_Controller</a> “”8042” PS/2 Controller”</li>
<li><a href="http://www.uruk.org/orig-grub/mem64mb.html" target="_blank" rel="external">http://www.uruk.org/orig-grub/mem64mb.html</a> “Query System Address Map”</li>
<li><a href="http://wiki.osdev.org/ATA\_PIO\_Mode" target="_blank" rel="external">http://wiki.osdev.org/ATA\_PIO\_Mode</a> “ATA PIO Mode”</li>
<li>滕启明 “ELF文件格式分析”</li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-excutff/" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/linux/l-excutff/</a> “UNIX/LINUX 平台可执行文件格式分析”</li>
</ol>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/os/" rel="tag"># os</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/08/13/基于SDN的简单load-balancer/" rel="next" title="基于SDN的简单load balancer">
                <i class="fa fa-chevron-left"></i> 基于SDN的简单load balancer
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="Wayne" />
          <p class="site-author-name" itemprop="name">Wayne</p>
           
              <p class="site-description motion-element" itemprop="description">Live your dream and share your passion!</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/1262119253" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/wayne508" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-总述"><span class="nav-number">1.</span> <span class="nav-text">1 总述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-准备"><span class="nav-number">2.</span> <span class="nav-text">2 准备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-打开A20"><span class="nav-number">3.</span> <span class="nav-text">3 打开A20</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-背景"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-8042控制器"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 8042控制器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-A20使能"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 A20使能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-探测物理内存分布"><span class="nav-number">4.</span> <span class="nav-text">4 探测物理内存分布</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-进入保护模式"><span class="nav-number">5.</span> <span class="nav-text">5 进入保护模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-加载内核"><span class="nav-number">6.</span> <span class="nav-text">6 加载内核</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-磁盘操作"><span class="nav-number">6.1.</span> <span class="nav-text">6.1 磁盘操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-读取扇区"><span class="nav-number">6.2.</span> <span class="nav-text">6.2 读取扇区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-ELF文件"><span class="nav-number">6.3.</span> <span class="nav-text">6.3 ELF文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-参考"><span class="nav-number">7.</span> <span class="nav-text">7 参考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wayne</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    
      <script id="dsq-count-scr" src="https://wayne508.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://roughtale.info/2015/08/20/ucore源码分析：bootloader/';
          this.page.identifier = '2015/08/20/ucore源码分析：bootloader/';
          this.page.title = 'ucore源码分析：bootloader';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://wayne508.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (search_path.endsWith("json")) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
